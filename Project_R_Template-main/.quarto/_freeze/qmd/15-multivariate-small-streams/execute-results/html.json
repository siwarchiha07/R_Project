{
  "hash": "bd32cdf895ad3713a4ae60860f0f2b71",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"15-Multivariate Analysis of Macrozoobenthos Samples from Two Small Streams\"\ndate: '2025-01-21'\n---\n\n\n\n# Introduction\n\nThe aim of the following exercise is to demonstrate some important\nmultivariate methods by example of a macrozoobenthos data set from \ntwo small streams. In some cases, several alternatives are presented, \nbut for a real analysis one does not need to include everything. \nOn the other hand, the methods offer further possibilities that \ncannot all be presented, see the online help and corresponding \nbooks and tutorials.\n\nThe data set used originates from a field experiment to investigate\nthe influence of fish predation on the macrozoobenthos species \ncomposition. However, during the study period an extreme flood \noccurred in August and caused major morphological changes to the \nstreams. This motivated the hypothesis that the species community \nhas also changed.\n\n# Material and Methods\n\nThe data set originates from the two streams, \"Gauernitzbach\" and\n\"Tännichtgrundbach\" near Dresden. It contains a table of\nmacrozoobenthos taxa and a description of the sites (t =\nTännichtgrund, g = Gauernitz, p = pool, r = riffle) and the time\nbefore (v) and after (n)) the flood. The variable names were left\nin German with Bach (stream), Hochwasser (before and after the flood),\nHabitat and Site. This may be changed in the future.\nThe data set is a subset from a longer project. \nTo make it accessible as a teaching example, the \nrelatively large number of species of the original data was \npragmatically aggregated to a small number of taxa. \nMore about the experiment can be found in\n[@Winkelmann2008;@Winkelmann2011].\n\nThe data set is available from\n[https://tpetzoldt.github.io/datasets/data/gauernitz.csv](https://tpetzoldt.github.io/datasets/data/gauernitz.csv),\ntogether with a [file description](https://tpetzoldt.github.io/datasets/data/gauernitz_info.txt).\n\nAfter reading the data in with `read.csv` row names are assigned to the \ndata frame from the `site` column that contains short codes for the observarions,\ne.g. `GP9` than means Gauernitzbach, pool, September. These rownames\nare very useful to indicate the observations in the plots.\n\nIn a second step, we split the original data frame in two separate tables\n`bio` with the taxonomic data only and `env` with the environmental\nfactors. For the calculations, it is important that the `bio`-table\ncontains only numbers. The data analysis is carried out with the **vegan** \npackage [@Oksanen2024]. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"dplyr\")\nlibrary(\"vegan\")\ndat <- read.csv(\"gauernitz.csv\")\n\n## assign rownames to dataframe\nrow.names(dat) <- dat$site\n\n## separate into two matrices, bio und env\nenv <- dat |> select(Habitat, Bach, Hochwasser)\nbio <- dat |> select(Mollusca, Diptera, Baetis, Plecoptera, Coleoptera,\n             Turbellaria, Heptageniidae, Ephemeroptera, Gammarus,\n             Trichoptera, Acari, Nematoda, Oligochaeta)\n```\n:::\n\n\nAfter loading the data, it is always important to have a look at the\ndata structure, for example with `str(bio)`, `str(env)` or in the\n\"Global Environment\" pane of RStudio.\n\n# Data Analysis\n\n## NMDS\n\nWe start with an NMDS (nonmetric multidimensional scaling) of the\n`bio`-data using the Bray-Curtis dissimilarity measure. It is the\ndefault of `metaMDS`, but we specify it explicitly to make the selection \nof the dissimilarity measure clearly visible in the code. \nAutomatic transformation is switched off. This can be\nchanged, depending on the properties of the data, or enabled \"manually\" \nfor example with `wisconsin(sqrt(bio))`.\n\nThe function `metaMDS` then runs the NMDS several times with different\nstarting values to avoid local minima. For difficult data sets, it may\nbe necessary to increase the metaparameters `try` and `trymax`, see \nhelpfile for details.\n\nAfter that, we should have a look at the stress value and the stressplot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmds <- metaMDS(bio, distance = \"bray\", autotransform = FALSE)\nmds\nstressplot(mds)\n```\n:::\n\n\nWe can then plot the results of the NMDS-ordination.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(mds, type = \"t\")\n```\n:::\n\n\nIn order to show the influence of environmental variables, we can fit\nvectors or factors to the ordination. In addition to this, we can show\nthe significance of the fitted vectors. For getting reliable p-values,\nI recommend to increase `permu` to 3999 or 9999.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## fit environmental factors and perform a permutations-test\nefit <- envfit(mds ~ Hochwasser + Bach + Habitat, env, permu = 999)\nefit\n```\n:::\n\n\nNow, we can visualize the complete result. Grey dotted zero-lines \nare added to make interpretation easier.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(mds, type = \"t\")\nplot(efit, add = TRUE)\nabline(h=0, col=\"grey\", lty=\"dotted\")\nabline(v=0, col=\"grey\", lty=\"dotted\")\n```\n:::\n\n\n## Hierarchical Clustering\n\nThe NMDS tries to project the distances as good as possible to a low\nnumber of dimensions, e.g. `k=2` that is the default. To see the full\npicture of distances in multidimensional space, we may consider to apply hierarchical\nclustering. As agglomeration algorithm, `complete`,\n`ward.D2` or `ward.D` can be a good choice. To improve understanding it can be a good idea to compare it \nwith other agglomeration schemes, e.g. `single`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhc <- hclust(vegdist(bio), method=\"ward.D\")\nplot(hc)\n```\n:::\n\n\nIt is also possible, to colorize the clusters in the NMDS plot. Let's\nassume we have 4 clusters, we can first indicate it in the\nhierarchical cluster tree with `rect.hclust``, then cut the tree with\n`cutree`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hc)\nrect.hclust(hc, 4)\ngrp <- cutree(hc, 4)  # assign observations to 4 groups\ngrp\n```\n:::\n\n\nThe result is an assignment of the original observations to groups,\nthat can be used to colorize the NMDS plot. It is possible to show the\ncluster tree directly in the nmds plot or to indicate it otherwise\nwith, for example, `ordispider`, `ordihull` or `ordiellipse`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(mds, type = \"n\")\ntext(mds$points, row.names(bio), col = grp)\n\n## optional: show cluster tree\n#ordicluster(mds, hc, col=\"blue\")\n```\n:::\n\n\n**Exercises:** Compare different agglomeration schemes, try different \nnumbers of clusters in `rect.hclust` and `cutree` and add the fitted\nenvironmental variables in the final plot.\n\n## Canonical Correspondence Analysis\n\nAs an alternative to NMDS, we can also use CCA, that is a \"constraied\nordination method\" and allows a more detailed numerical analysis\n(e.g. separatation of inertia), but is limited to $\\chi^2$-distance,\nwhile NMDS allows arbitrary distance measures, including Bray-Curtis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc <- cca(bio ~ Habitat + Bach + Hochwasser, data = env)\n#cc <- cca(bio ~ ., data = env) # same. The . means all from env\ncc # print Eigenvalues\nplot(cc)\nordihull(cc, env$Habitat, col = \"blue\")   # or: ordispider, ordiellipse ...\n```\n:::\n\n\n## Test of significance\n\nThe CCA supports also significance tests and model selection with ANOVA-like \npermutation tests.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Resampling-ANOVAs of the CCA\nanova(cc)\nanova(cc, by = \"terms\") # most useful\nanova(cc, by = \"axis\")\n\n## Model selection to find the optimal model\nstep(cc)\n```\n:::\n\n\nSeveral other multivariate significance tests exist. The Adonis-Test\nis in particular popular, because it considers also interaction\nterms. It does not rely on an NMDS or CCA and works directly with a\ndistance matrix. In order to increase its power, we may optionally\nconsider strata. The following shows some examples.\n\n**Exercise:** Try different model formulae and decide which one is\nmost appropriate for the data set and the original hypothesis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist <- vegdist(bio, method = \"bray\")\n\nadonis2(dist ~ Hochwasser * Habitat * Bach, data = dat, by = \"terms\")\n\n## Comparison with and without strata\nadonis2(dist ~ Hochwasser * Bach, strata = env$Habitat, data = dat, by = \"terms\")\nadonis2(dist ~ Hochwasser * Bach, data = dat, by = \"terms\")\n```\n:::\n\n\n## dbRDA and elimination of covariates\n\nThe following examples show further possibilities. Instead of a CCA\n(that uses $\\chi^2$) we can also use a so-called distance-based\nredundancy analysis (dbRDA), that supports arbitrary distance\nmeasures, e.g. Bray-Curtis.\n\nAnother option is a partial CCA or partial dbRDA where we can\neliminate covariates (`condtion = ...`) that we are not much\ninterested in, so that the ordination focuses on the variables we are\ninterested in. This is the called a partial analysis (pCCA, p-dbRDA).\nWe will then also get three kinds of eigenvalues and eigenvectors\n(components of the inertia).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## =========================================================================\n## dbRDA, supports arbitrary dissimilarity measures\n## =========================================================================\n\ndbr <- dbrda(dist ~ Habitat + Bach + Hochwasser, data = env, distance = \"bray\")\ndbr\nanova(dbr, by=\"terms\", permutations=3999)\n#summary(dbr)\nplot(dbr)\n\n## =========================================================================\n## partial CCA: elimination of covariates\n## =========================================================================\npcc <- cca(bio ~ Hochwasser + Bach + Condition(Habitat), data = env)\npcc\nplot(pcc)\n\n\n## =========================================================================\n## partial dbRDA\n## =========================================================================\ndbrc <- dbrda(bio ~ Hochwasser + Bach + Condition(Habitat), \n              data = env, distance = \"bray\")\ndbrc\nplot(dbrc)\n```\n:::\n\n\n**Exercise**: Apply a method that eliminates the differences between \nthe streams and investigate whether pools and riffles behave differently.\n\n## Procrustes test\n\nTo compare the ordinations, that we get with a different set of\nenvironmental variable and conditions, we can use the so-called\nProcrustes test.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbr  <- dbrda(bio ~ Hochwasser + Bach + Habitat, \n              data = env, distance=\"bray\")\npdbr <- dbrda(bio ~ Hochwasser + Bach + Condition(Habitat), \n              data = env, distance=\"bray\")\n\nproc <- procrustes(dbr, pdbr)\nplot(proc, type = \"t\")\nprotest(dbr, pdbr)\n```\n:::\n\n\n# Final recommendations\n\nMultivariate methods are excellent tools for the explorative analysis \nof larger data sets. However, it is easy to get lost in the variety of \nmethods and plots, and multivariate ordination programs are not always \neasy to understand. It is therefore a good idea to summarize the main\nresults afterwards with simpler graphics and summary statistics.\n\n**Exercise:** Create some (e.g. 2-3) bar charts and/or x-y-plots to visualize main results, e.g.\nabundance of typical taxa or classical diversity indices like Simpson's index and\ninterpret the results.\n\nThe following code example shows one of the taxa and \nthe Simpson index for all sites. \nNow find meaningful aggregations of sites (e.g. stream, pool-riffle, time or cluster)\nto vizualize main results of the multivariate analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(bio$Mollusca, names.arg=dat$Site, horiz=TRUE, las=1)\nbarplot(diversity(bio, index=\"simpson\"), names.arg=dat$Site, horiz=TRUE, las=1)\n```\n:::\n\n\n\n# References\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}