{
  "hash": "05022e81e4e80219413c3a025e41bd11",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"13-Identification of Breakpoints in Time Series\"\ndate: \"2025-01-13\"\n---\n\n\n\n\n\n# Introduction\n\nThe example is adapted from the help pages of R package **strucchange**, \n[@Zeileis2002]. The scientific question is to detect breakpoints where the\nhydrological regime of a river suddenly changed due to management changes, \ne.g. dam construction.\n\n# Methods\n\n## Dataset\n\nThe dataset is a hydrological time series of the discharge of the river Nile \nmeasured at Aswan in 10^8^ m^3^ a^-1^. The origin of the data is described in \n@Cobb1978. It is contained in the **strucchange** package and can be loaded with `data(Nile)`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"strucchange\")\ndata(\"Nile\")\nplot(Nile)\n```\n:::\n\n\n\n## Data analysis\n\nThe data analysis is carried out in several steps:\n\n1. Statistical test if the time series contains breakpoints\n2. Identification of number and position of breakpoints\n3. Visualization of model results\n4. Diagnostic tests\n\n# Results\n\n## Test of existence of breakpoints\n\nHere we use a so-called OLS-CUSUM test (ordinary least-squares regression, \ncumulative sums). The technical procedure is that we first define a null \nhypothesis for an empirical fluctuation process (`efp`). Here the model `Nile ~ 1` means that we assume a constant mean value over time without trend. In case we allow for a linear trend, we could use `Nile ~ time (Nile)`.\n\nThe `ocus` (OLS-CUSUM) object is then plotted and a structural change test (`sctest`) applied. \nThe y-axis of the plot is scaled in units of standard deviations. The line shows the cumulative sum of deviations from the mean value. An monotonous increase of the line means that values are above the arithmetic mean, a decrease that they are below average. If the line exceeds the horizontal confidence bands, it indicates a structural change.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nocus <- efp(Nile ~ 1, type = \"OLS-CUSUM\")\nplot(ocus)\n```\n\n::: {.cell-output-display}\n![](13-timeseries-breakpoints_files/figure-html/ols-cusum-1.png){width=672}\n:::\n\n```{.r .cell-code}\nsctest(ocus)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tOLS-based CUSUM test\n\ndata:  ocus\nS0 = 2.9518, p-value = 5.409e-08\n```\n\n\n:::\n:::\n\n\n## Identification of structural breaks\n\nFunction `breakpoints`is the main workhorse of the package. It iteratively scans \nthe time series for candidate breakpoints, that can be printed. The BIC values \nreturned by summary or and that are visible in the plot are then used for model \nselection. We select the model with the minimum BIC. Here we use again a model\nwithout trend (`Nile ~ 1`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp.nile <- breakpoints(Nile ~ 1)\nsummary(bp.nile)\n\nplot(bp.nile)\n```\n:::\n\n\n**Task:** find out how many breakpoints are necessary for an optimal model and \nat which time they occured.\n\n## Visualisation\n\nIn the following, we compare the model with **N** breakpoints with the null model \n`fm0` without any breakpoint. In addition, we can also show indcate the confidence interval.\n\n**Task:** replace `xxx`with the correct number of breakpoints. It is also possible, \nto try other numbers of breakpoints to understand the algorith. Finally set it back to the optimal value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfm0 <- lm(Nile ~ 1)\nfm1 <- lm(Nile ~ breakfactor(bp.nile,  breaks = xxx))\nplot(Nile)\nlines(ts(fitted(fm0),  start = 1871),  col = 3)\nlines(ts(fitted(fm1),  start = 1871),  col = 4)\nlines(bp.nile)\n\n## confidence interval\nci.nile <- confint(bp.nile)\nci.nile\nlines(ci.nile)\n```\n:::\n\nThe optional code uses a simpler and less fancy method for indicating the breakpoint(s).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(Nile)\ndat <- data.frame(time = time(Nile), Q = as.vector(Nile))\nabline(v = dat$time[bp.nile$breakpoints],  col = \"green\")\n```\n:::\n\n\nIf we need a p-value, we can compare the two models with a likelihood ratio test:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## ANOVA test whether the two models are significantly different\nanova(fm0, fm1)\n```\n:::\n\n\n## Diagnostics\n\nFinally let's check autocorrelation and normality of residuals. In case the \nbreakpoint model was appropriate, autocorrelations should vanish. As a counterexample, \nwe plot also the autocorrelation function of the null model (`fm1`).\n\nFinally, we check  residuals for approximate normality.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(2, 2))\nacf(residuals(fm0))\nacf(residuals(fm1))\nqqnorm(residuals(fm0))\nqqnorm(residuals(fm1))\n```\n:::\n\n\n# Discussion\n\nNow we come back to the original objective and its implications. How many breakpoints \nwere found in he time series, when and in which direction? What happened in the \nyear(s) of the identified breakpoints? Read the article about the Aswan Dam in Wikipedia [https://en.wikipedia.org/wiki/Aswan_Dam](https://en.wikipedia.org/wiki/Aswan_Dam). Then look at the time series again:\n\n* When you would expect structural breaks? Why?\n* Hint: Looking closer, there is another breakpoint, not identified by the algorithm. \n* How can this be explained?\n\n# References\n",
    "supporting": [
      "13-timeseries-breakpoints_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}