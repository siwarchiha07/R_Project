{"title":"Analyse Statistique des Profils GitHub Influents","markdown":{"yaml":{"title":"Analyse Statistique des Profils GitHub Influents","date":"today","format":{"html":{"toc":true,"number-sections":true,"code-fold":false,"code-summary":"Afficher le code"}},"webr":{"packages":["tidyverse","ggplot2","wordcloud","RColorBrewer","stringr"]},"filters":["webr"]},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n\nCe document présente une analyse statistique complète des profils GitHub les plus influents à travers le monde. GitHub est la plateforme de référence pour le développement collaboratif, et le nombre d'étoiles (stars) récoltées par un utilisateur est devenu un indicateur clé de sa popularité et de son impact dans la communauté Open Source.\n\n## Objectifs de l'analyse\n\nNous tenterons de répondre aux questions suivantes :\n\n1. **Distribution de la popularité** : Comment la popularité est-elle distribuée entre ces différents profils ?\n2. **Impact des langages** : Le choix des langages de programmation (comme Python ou JavaScript) influence-t-il le succès d'un profil ?\n3. **Types de profils** : Existe-t-il des différences notables entre les comptes individuels et les organisations ?\n4. **Diversité technologique** : La diversité des langages utilisés est-elle corrélée à la popularité ?\n\n# Chargement des bibliothèques et des données\n\n## Installation et chargement des packages\n\n```{webr-r}\n# Installation des packages (si nécessaire)\n# install.packages(\"tidyverse\")\n# install.packages(\"wordcloud\")\n# install.packages(\"RColorBrewer\")\n\n# Chargement des bibliothèques\nlibrary(tidyverse)\nlibrary(wordcloud)\nlibrary(RColorBrewer)\n```\n\n## Lecture du fichier de données\n\n```{webr-r}\n# Lecture du fichier CSV (remonter d'un niveau depuis qmd/)\ndf <- read.csv(\"https://raw.githubusercontent.com/siwarchiha07/R_Project/main/profiles_index.csv\", stringsAsFactors = FALSE)\n\n# Aperçu des données\ncat(\"Dimensions du dataset :\", dim(df), \"\\n\")\n```\n\n```{webr-r}\n# Affichage des premières lignes\nhead(df)\n```\n\n```{webr-r}\n# Structure des données (vérification des types de colonnes)\nstr(df)\n```\n\n**Interprétation :** Le dataset contient 30 profils GitHub avec 7 variables principales. La structure des données révèle que chaque profil possède un identifiant unique (login), des informations personnelles (nom, entreprise, localisation), ainsi que des métriques quantitatives (total_stars, nb_repos_fetched) et qualitatives (languages_list). La lecture depuis une URL garantit que les données sont toujours à jour et accessibles.\n\n# Nettoyage et transformation des données\n\n## Remplacement des valeurs manquantes\n\n```{webr-r}\n# Remplacement des valeurs vides par \"Unknown\" dans Location et Company\ndf$location[df$location == \"\" | is.na(df$location)] <- \"Unknown\"\ndf$company[df$company == \"\" | is.na(df$company)] <- \"Unknown\"\n```\n\n**Interprétation :** Le remplacement des valeurs manquantes par \"Unknown\" permet de conserver tous les profils dans l'analyse sans perte d'information. Cette approche est appropriée car certaines informations peuvent simplement ne pas être renseignées par les utilisateurs GitHub plutôt que d'être réellement manquantes. Cela évite les biais liés à l'élimination des données incomplètes.\n\n## Création de variables \"flags\" pour les langages\n\n```{webr-r}\n# Création de variables booléennes pour les langages les plus populaires\ndf <- df %>%\n  mutate(\n    has_python = grepl(\"Python\", languages_list),\n    has_javascript = grepl(\"JavaScript\", languages_list),\n    has_typescript = grepl(\"TypeScript\", languages_list)\n  )\n\n# Vérification du résultat\nhead(df[, c(\"login\", \"total_stars\", \"has_python\", \"has_javascript\", \"has_typescript\")])\n```\n\n**Interprétation :** La création de variables booléennes facilite l'analyse comparative entre profils utilisant ou non un langage donné. Ces variables permettent de tester si l'utilisation d'un langage spécifique est associée à une popularité différente. Python, JavaScript et TypeScript sont choisis car ce sont parmi les langages les plus populaires et demandés dans l'écosystème de développement moderne.\n\n# Analyse descriptive et graphiques\n\n## Statistiques descriptives\n\n```{webr-r}\n# Statistiques descriptives pour les variables quantitatives\nsummary(df[, c(\"total_stars\", \"nb_repos_fetched\")])\n```\n\n```{webr-r}\n# Fréquences pour certaines variables qualitatives\ncat(\"\\n=== Distribution par langage Python ===\\n\")\ntable(df$has_python)\n\ncat(\"\\n=== Distribution par langage JavaScript ===\\n\")\ntable(df$has_javascript)\n\ncat(\"\\n=== Distribution par langage TypeScript ===\\n\")\ntable(df$has_typescript)\n```\n\n**Interprétation :** Les statistiques descriptives révèlent une importante variabilité dans le nombre d'étoiles, avec des valeurs extrêmes qui suggèrent une distribution asymétrique. La médiane et la moyenne du nombre d'étoiles sont probablement très différentes, indiquant la présence de quelques profils exceptionnellement populaires. Les tableaux de fréquences montrent la prévalence de chaque langage dans l'échantillon, permettant d'identifier les langages les plus représentés.\n\n## Distribution du nombre total d'étoiles\n\n```{webr-r}\n# Histogramme de la distribution des étoiles\nggplot(df, aes(x = total_stars)) +\n  geom_histogram(fill = \"steelblue\", bins = 15, color = \"white\") +\n  labs(\n    title = \"Distribution du nombre total d'étoiles\",\n    subtitle = \"Répartition de la popularité parmi les profils GitHub\",\n    x = \"Nombre d'étoiles\",\n    y = \"Fréquence\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 14, face = \"bold\"),\n    plot.subtitle = element_text(size = 12)\n  )\n```\n\n**Interprétation :** L'histogramme révèle une distribution fortement asymétrique (skewed right) avec une queue longue vers les valeurs élevées. Cela signifie que la majorité des profils ont un nombre modéré d'étoiles, tandis qu'un petit nombre de profils concentrent une part disproportionnée de la popularité totale. Cette distribution suit probablement une loi de Pareto (loi des 80/20), caractéristique des systèmes sociaux où quelques acteurs dominent.\n\n## Impact des langages sur la popularité\n\n### Python\n\n```{webr-r}\n# Boxplot : Python vs les autres\nggplot(df, aes(x = has_python, y = total_stars, fill = has_python)) +\n  geom_boxplot(alpha = 0.7) +\n  scale_y_log10() +  # Utilisation d'une échelle log car les écarts sont énormes\n  labs(\n    title = \"Popularité : Profils Python vs Autres\",\n    subtitle = \"Comparaison du nombre d'étoiles (échelle logarithmique)\",\n    x = \"Utilise Python\",\n    y = \"Total Stars (Log Scale)\"\n  ) +\n  scale_fill_manual(values = c(\"FALSE\" = \"#E8E8E8\", \"TRUE\" = \"#377EB8\")) +\n  theme_light() +\n  theme(legend.position = \"none\")\n```\n\n**Interprétation :** Le boxplot en échelle logarithmique permet de comparer visuellement la distribution des étoiles entre les deux groupes. Si les boîtes à moustaches sont à des hauteurs différentes, cela suggère un écart potentiel de popularité. L'échelle logarithmique est essentielle ici car elle compresse les très grandes différences et rend la visualisation lisible. Une médiane plus élevée pour le groupe \"Python = TRUE\" suggérerait que Python pourrait être associé à une plus grande popularité.\n\n### JavaScript\n\n```{webr-r}\n# Impact de JavaScript sur la popularité\nggplot(df, aes(x = has_javascript, y = total_stars, fill = has_javascript)) +\n  geom_boxplot(alpha = 0.7) +\n  scale_y_log10() +\n  labs(\n    title = \"Impact de JavaScript sur la popularité\",\n    subtitle = \"Comparaison du nombre d'étoiles (échelle logarithmique)\",\n    x = \"Utilise JavaScript\",\n    y = \"Total Stars (Log)\"\n  ) +\n  scale_fill_manual(values = c(\"FALSE\" = \"#E8E8E8\", \"TRUE\" = \"#FDB462\")) +\n  theme_classic() +\n  theme(legend.position = \"none\")\n```\n\n**Interprétation :** Similaire à l'analyse Python, ce graphique compare la popularité des profils utilisant JavaScript. JavaScript étant le langage le plus utilisé pour le développement web, on pourrait s'attendre à ce que les profils utilisant JavaScript soient plus nombreux. Cependant, cela ne garantit pas nécessairement une plus grande popularité moyenne, car la qualité et la visibilité des projets sont plus importantes que le simple choix technologique.\n\n# Tests statistiques\n\n## Test de Wilcoxon pour Python\n\n**Question de recherche** : Est-ce que les profils utilisant Python ont significativement plus d'étoiles que les autres ?\n\n```{webr-r}\n# Test statistique de Wilcoxon pour Python\ncat(\"=== Test de différence significative pour Python ===\\n\")\ntest_python <- wilcox.test(total_stars ~ has_python, data = df)\nprint(test_python)\n\n# Interprétation\nif (test_python$p.value < 0.05) {\n  cat(\"\\n✓ Résultat significatif (p < 0.05) : Il existe une différence significative\\n\")\n} else {\n  cat(\"\\n✗ Résultat non significatif (p >= 0.05) : Pas de différence significative détectée\\n\")\n}\n```\n\n**Interprétation :** Le test de Wilcoxon (test non-paramétrique de Mann-Whitney) est choisi car il ne fait pas d'hypothèse sur la distribution normale des données, ce qui est approprié ici compte tenu de l'asymétrie observée. Si p < 0.05, on rejette l'hypothèse nulle d'égalité des distributions et on conclut qu'il existe une différence statistiquement significative entre les deux groupes. Cependant, un résultat significatif ne signifie pas nécessairement une causalité - il pourrait s'agir d'une simple corrélation due à d'autres facteurs.\n\n## Test de Wilcoxon pour JavaScript\n\n```{webr-r}\n# Test statistique de Wilcoxon pour JavaScript\ncat(\"=== Test de différence significative pour JavaScript ===\\n\")\ntest_javascript <- wilcox.test(total_stars ~ has_javascript, data = df)\nprint(test_javascript)\n\n# Interprétation\nif (test_javascript$p.value < 0.05) {\n  cat(\"\\n✓ Résultat significatif (p < 0.05) : Il existe une différence significative\\n\")\n} else {\n  cat(\"\\n✗ Résultat non significatif (p >= 0.05) : Pas de différence significative détectée\\n\")\n}\n```\n\n**Interprétation :** De la même manière que pour Python, ce test évalue si l'utilisation de JavaScript est associée à une différence significative de popularité. Un résultat non significatif pourrait indiquer que JavaScript est si répandu qu'il n'apporte pas de distinction particulière, ou que d'autres facteurs (qualité du code, timing, marketing) sont plus déterminants pour le succès que le simple choix du langage.\n\n# Organisations vs Individus\n\n```{webr-r}\n# Identification des organisations dans le dataset\norgs_list <- c(\"openai\", \"github\", \"microsoft\", \"google\")\n\ndf <- df %>%\n  mutate(\n    type_profil = ifelse(login %in% orgs_list, \"Organisation\", \"Individu\")\n  )\n\n# Vérification\ntable(df$type_profil)\n```\n\n```{webr-r}\n# Visualisation : Organisations vs Individus\nggplot(df, aes(x = type_profil, y = total_stars, fill = type_profil)) +\n  geom_boxplot(alpha = 0.7) +\n  scale_y_log10() +  # Échelle log pour mieux voir la différence\n  labs(\n    title = \"Popularité : Organisations vs Individus\",\n    subtitle = \"Comparaison du nombre d'étoiles (échelle logarithmique)\",\n    x = \"Type de Profil\",\n    y = \"Total Stars (Log Scale)\"\n  ) +\n  scale_fill_manual(values = c(\"Individu\" = \"#66C2A5\", \"Organisation\" = \"#FC8D62\")) +\n  theme_light() +\n  theme(legend.position = \"none\")\n```\n\n**Interprétation :** Cette comparaison permet d'évaluer si les organisations ont un avantage structurel (ressources, équipes, visibilité) par rapport aux développeurs individuels. Les organisations majeures bénéficient généralement de budgets marketing, de communautés établies et de ressources pour maintenir et promouvoir leurs projets. Cependant, l'échantillon est petit pour les organisations (4 sur 30), ce qui limite la généralisation des résultats. Si les organisations montrent une popularité plus élevée, cela pourrait refléter leur capacité à investir dans le marketing et la maintenance à long terme.\n\n# Relation entre quantité de dépôts et popularité\n\n```{webr-r}\n# Relation entre nombre de dépôts et popularité\nggplot(df, aes(x = nb_repos_fetched, y = total_stars)) +\n  geom_point(color = \"darkgreen\", size = 3, alpha = 0.7) +\n  geom_smooth(method = \"lm\", color = \"red\", linetype = \"dashed\", se = TRUE) +\n  labs(\n    title = \"Relation : Nombre de dépôts récupérés vs Stars\",\n    subtitle = \"Si la ligne est plate, la quantité n'influence pas la popularité\",\n    x = \"Nombre de dépôts (nb_repos_fetched)\",\n    y = \"Total Stars\"\n  ) +\n  theme_minimal()\n```\n\n**Interprétation :** Ce graphique explore si \"plus de projets = plus de popularité\". La ligne de régression montre la tendance générale : une pente positive suggère que publier plus de projets pourrait augmenter la visibilité, tandis qu'une ligne plate indiquerait que la quantité n'est pas le facteur déterminant. Cependant, la relation pourrait être inverse : certains profils très populaires peuvent avoir moins de projets mais de meilleure qualité. La bande de confiance (zone grise) montre l'incertitude autour de cette relation.\n\n## Test de corrélation\n\n```{webr-r}\n# Test de corrélation entre nombre de dépôts et étoiles\ncor_test_repos <- cor.test(df$nb_repos_fetched, df$total_stars, method = \"spearman\")\ncat(\"=== Test de corrélation (Spearman) ===\\n\")\nprint(cor_test_repos)\n```\n\n**Interprétation :** Le test de corrélation de Spearman mesure la force de la relation monotone (pas nécessairement linéaire) entre les deux variables. Un coefficient proche de 0 indique l'absence de corrélation, tandis qu'une valeur proche de +1 ou -1 indique une forte corrélation positive ou négative. Le test de Spearman est préféré au test de Pearson car il est plus robuste aux valeurs aberrantes et ne nécessite pas d'hypothèse de normalité.\n\n# Analyse de la diversité technologique\n\n## Calcul du nombre de langages par profil\n\n```{webr-r}\n# Calculer le nombre de langages par profil\ndf$num_languages <- stringr::str_count(df$languages_list, \",\") + 1\n\n# Statistiques descriptives\ncat(\"=== Statistiques sur le nombre de langages ===\\n\")\nsummary(df$num_languages)\n\n# Visualisation\nggplot(df, aes(x = num_languages)) +\n  geom_histogram(fill = \"purple\", bins = 10, color = \"white\", alpha = 0.7) +\n  labs(\n    title = \"Distribution du nombre de langages utilisés\",\n    x = \"Nombre de langages\",\n    y = \"Fréquence\"\n  ) +\n  theme_minimal()\n```\n\n**Interprétation :** Le calcul du nombre de langages permet d'évaluer la diversité technologique de chaque profil. Un nombre élevé de langages pourrait indiquer une polyvalence technique, mais aussi une dispersion potentielle des efforts. L'histogramme montre la distribution de cette diversité dans l'échantillon, révélant si la plupart des profils se spécialisent (peu de langages) ou sont polyvalents (beaucoup de langages).\n\n## Corrélation entre diversité et popularité\n\n```{webr-r}\n# Test de corrélation de Spearman (adapté aux petites données non-normales)\ncor_test_lang <- cor.test(df$num_languages, df$total_stars, method = \"spearman\")\n\ncat(\"=== Test de corrélation : Nombre de langages vs Popularité ===\\n\")\nprint(cor_test_lang)\n```\n\n**Interprétation :** Ce test évalue si la diversité technologique est un atout ou un handicap pour la popularité. Une corrélation positive suggérerait que la polyvalence est appréciée, tandis qu'une corrélation négative pourrait indiquer que la spécialisation mène à de meilleurs résultats. Une absence de corrélation significative signifierait que la diversité technologique n'est pas un facteur déterminant de la popularité.\n\n```{webr-r}\n# Visualisation de la relation\nggplot(df, aes(x = num_languages, y = total_stars)) +\n  geom_point(aes(color = total_stars), size = 3, alpha = 0.7) +\n  geom_smooth(method = \"lm\", se = TRUE, color = \"red\", linetype = \"dashed\") +\n  scale_y_log10() +\n  scale_color_gradient(low = \"blue\", high = \"red\") +\n  labs(\n    title = \"Diversité technologique vs Popularité\",\n    subtitle = \"Relation entre le nombre de langages et le nombre d'étoiles\",\n    x = \"Nombre de langages utilisés\",\n    y = \"Total Stars (Log)\",\n    color = \"Étoiles\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"right\")\n```\n\n**Interprétation :** Le nuage de points avec gradient de couleur permet de visualiser à la fois la relation entre diversité et popularité, ainsi que l'identification visuelle des profils les plus populaires (points rouges). La ligne de régression indique la tendance générale, mais les points individuels peuvent révéler des exceptions intéressantes. Par exemple, certains profils peuvent être très populaires avec peu de langages (spécialisation réussie) ou avec beaucoup de langages (polyvalence réussie).\n\n# Analyse de la \"puissance\" des langages\n\n## Identification des superstars\n\n```{webr-r}\n# Définir le seuil du top 25%\nseuil_top <- quantile(df$total_stars, 0.75)\ndf$is_superstar <- df$total_stars >= seuil_top\n\ncat(\"=== Seuil pour être considéré comme 'Superstar' (top 25%) ===\\n\")\ncat(\"Seuil :\", seuil_top, \"étoiles\\n\\n\")\ncat(\"Nombre de superstars :\", sum(df$is_superstar), \"\\n\")\n```\n\n**Interprétation :** La définition des \"superstars\" comme étant dans le top 25% permet de créer un groupe d'élite pour comparaison. Le quantile 0.75 (Q3) est un seuil objectif qui sépare naturellement les profils les plus performants. Environ 7-8 profils devraient être identifiés comme superstars, ce qui représente un échantillon suffisant pour des comparaisons statistiques significatives.\n\n## Comparaison des langages pour les superstars\n\n```{webr-r}\n# Comparaison des langages pour les superstars vs autres\nlang_summary <- df %>%\n  group_by(is_superstar) %>%\n  summarise(\n    Pct_Python = mean(has_python) * 100,\n    Pct_JS = mean(has_javascript) * 100,\n    Pct_TS = mean(has_typescript) * 100,\n    .groups = \"drop\"\n  )\n\ncat(\"=== Pourcentage d'utilisation des langages ===\\n\")\ncat(\"Chez les Superstars vs Autres :\\n\")\nprint(lang_summary)\n```\n\n**Interprétation :** Cette analyse compare les préférences technologiques entre les profils les plus populaires et les autres. Si un langage apparaît significativement plus souvent chez les superstars, cela pourrait suggérer que ce langage offre des avantages (écosystème riche, communauté active, outils performants) ou que les superstars tendent à choisir ce langage pour des raisons stratégiques. Cependant, il faut éviter de conclure à une relation causale directe.\n\n## Visualisation comparée\n\n```{webr-r}\n# Préparation des données pour la visualisation\nlang_summary_long <- lang_summary %>%\n  pivot_longer(\n    cols = c(Pct_Python, Pct_JS, Pct_TS),\n    names_to = \"Langage\",\n    values_to = \"Pourcentage\"\n  ) %>%\n  mutate(\n    Langage = case_when(\n      Langage == \"Pct_Python\" ~ \"Python\",\n      Langage == \"Pct_JS\" ~ \"JavaScript\",\n      Langage == \"Pct_TS\" ~ \"TypeScript\"\n    ),\n    Type = ifelse(is_superstar, \"Superstar\", \"Autres\")\n  )\n\n# Graphique en barres groupées\nggplot(lang_summary_long, aes(x = Langage, y = Pourcentage, fill = Type)) +\n  geom_bar(stat = \"identity\", position = \"dodge\", alpha = 0.8) +\n  labs(\n    title = \"Utilisation des langages : Superstars vs Autres\",\n    subtitle = \"Pourcentage de profils utilisant chaque langage\",\n    x = \"Langage de programmation\",\n    y = \"Pourcentage (%)\",\n    fill = \"Type de profil\"\n  ) +\n  scale_fill_manual(values = c(\"Superstar\" = \"#E31A1C\", \"Autres\" = \"#1F78B4\")) +\n  theme_minimal() +\n  theme(legend.position = \"right\")\n```\n\n**Interprétation :** Le graphique en barres groupées permet une comparaison visuelle directe. Des barres de hauteur similaire indiquent que le langage est également utilisé dans les deux groupes, tandis que des différences importantes suggèrent une préférence marquée dans un groupe. Cette visualisation aide à identifier rapidement si certains langages sont des \"marchés\" des superstars ou si la répartition est homogène.\n\n# Détection des valeurs atypiques (Outliers)\n\n```{webr-r}\n# Identification des outliers avec la méthode IQR\nQ1 <- quantile(df$total_stars, 0.25)\nQ3 <- quantile(df$total_stars, 0.75)\nIQR_val <- Q3 - Q1\nborne_sup <- Q3 + 1.5 * IQR_val\n\noutliers <- df[df$total_stars > borne_sup, ]\n\ncat(\"=== Détection des valeurs atypiques (méthode IQR) ===\\n\")\ncat(\"Q1 :\", Q1, \"\\n\")\ncat(\"Q3 :\", Q3, \"\\n\")\ncat(\"IQR :\", IQR_val, \"\\n\")\ncat(\"Borne supérieure (Q3 + 1.5 × IQR) :\", borne_sup, \"\\n\\n\")\ncat(\"Nombre de profils considérés comme des anomalies statistiques (Superstars) :\", \n    nrow(outliers), \"\\n\\n\")\ncat(\"=== Profils identifiés comme outliers ===\\n\")\nprint(outliers[, c(\"login\", \"name\", \"total_stars\", \"company\")])\n```\n\n**Interprétation :** La méthode IQR (Interquartile Range) est une technique standard pour identifier les valeurs atypiques. Tout profil dont le nombre d'étoiles dépasse Q3 + 1.5×IQR est considéré comme un outlier. Ces profils sont statistiquement exceptionnels - ils se démarquent nettement du reste de la population. Identifier ces profils permet de comprendre les facteurs qui créent des succès exceptionnels, mais aussi de décider s'il faut les inclure ou les exclure de certaines analyses qui pourraient être biaisées par leur présence.\n\n```{webr-r}\n# Visualisation avec identification des outliers\nggplot(df, aes(x = \"\", y = total_stars)) +\n  geom_boxplot(fill = \"lightblue\", alpha = 0.7, outlier.color = \"red\", outlier.size = 3) +\n  scale_y_log10() +\n  labs(\n    title = \"Distribution des étoiles avec détection des outliers\",\n    subtitle = \"Les points rouges représentent les valeurs atypiques\",\n    x = \"\",\n    y = \"Total Stars (Log Scale)\"\n  ) +\n  theme_minimal()\n```\n\n**Interprétation :** Le boxplot visualise clairement les outliers comme des points rouges au-delà des moustaches. Cette représentation permet de voir immédiatement l'ampleur de l'écart entre les profils normaux et les exceptions. L'échelle logarithmique est cruciale ici car elle permet de voir à la fois les profils normaux et les outliers sur le même graphique, sans que les outliers masquent complètement la distribution principale.\n\n# Analyse de texte : Nuage de mots des entreprises\n\n```{webr-r}\n# Créer un tableau de fréquence des entreprises (en ignorant \"Unknown\" et valeurs vides)\ncomp_freq <- df %>%\n  filter(company != \"Unknown\" & company != \"\" & !is.na(company)) %>%\n  count(company, sort = TRUE)\n\n# Vérifier s'il y a des données\nif (nrow(comp_freq) > 0) {\n  # Créer le nuage de mots\n  wordcloud(\n    words = comp_freq$company,\n    freq = comp_freq$n,\n    min.freq = 1,\n    colors = brewer.pal(8, \"Dark2\"),\n    random.order = FALSE,\n    rot.per = 0.35,\n    scale = c(3, 0.5)\n  )\n  \n  cat(\"=== Fréquence des entreprises ===\\n\")\n  print(comp_freq)\n} else {\n  cat(\"Pas assez de données d'entreprises pour créer un nuage de mots.\\n\")\n}\n```\n\n**Interprétation :** Le nuage de mots (wordcloud) offre une visualisation intuitive de l'écosystème des entreprises représentées dans l'échantillon. La taille des mots est proportionnelle à leur fréquence, permettant d'identifier rapidement les entreprises les plus présentes. Cela révèle quelles organisations emploient ou attirent les développeurs les plus influents sur GitHub. Le tableau de fréquences fournit les valeurs exactes pour une analyse plus précise. Cette analyse contextuelle aide à comprendre l'environnement professionnel des profils étudiés.\n\n# Synthèse et conclusions\n\n## Résultats principaux\n\n```{webr-r}\ncat(\"=== SYNTHÈSE DES RÉSULTATS ===\\n\\n\")\n\n# 1. Distribution de la popularité\ncat(\"1. DISTRIBUTION DE LA POPULARITÉ\\n\")\ncat(\"   - Médiane des étoiles :\", median(df$total_stars), \"\\n\")\ncat(\"   - Moyenne des étoiles :\", round(mean(df$total_stars), 2), \"\\n\")\ncat(\"   - Écart-type :\", round(sd(df$total_stars), 2), \"\\n\\n\")\n\n# 2. Impact des langages\ncat(\"2. IMPACT DES LANGAGES\\n\")\ncat(\"   - Profils utilisant Python :\", sum(df$has_python), \"sur\", nrow(df), \"\\n\")\ncat(\"   - Profils utilisant JavaScript :\", sum(df$has_javascript), \"sur\", nrow(df), \"\\n\")\ncat(\"   - Profils utilisant TypeScript :\", sum(df$has_typescript), \"sur\", nrow(df), \"\\n\\n\")\n\n# 3. Types de profils\ncat(\"3. TYPES DE PROFILS\\n\")\nprofile_summary <- df %>%\n  group_by(type_profil) %>%\n  summarise(\n    Nombre = n(),\n    Moyenne_étoiles = round(mean(total_stars), 2),\n    Médiane_étoiles = round(median(total_stars), 2),\n    .groups = \"drop\"\n  )\nprint(profile_summary)\ncat(\"\\n\")\n\n# 4. Diversité technologique\ncat(\"4. DIVERSITÉ TECHNOLOGIQUE\\n\")\ncat(\"   - Nombre moyen de langages :\", round(mean(df$num_languages), 2), \"\\n\")\ncat(\"   - Nombre médian de langages :\", median(df$num_languages), \"\\n\")\ncat(\"   - Corrélation avec la popularité (Spearman) :\", \n    round(cor_test_lang$estimate, 3), \"\\n\")\ncat(\"   - p-value :\", round(cor_test_lang$p.value, 4), \"\\n\")\n```\n\n**Interprétation :** Cette synthèse quantitative résume les principales découvertes de l'analyse. La comparaison entre médiane et moyenne révèle le degré d'asymétrie : si la moyenne est beaucoup plus élevée que la médiane, cela confirme la présence de quelques profils extrêmement populaires qui tirent la moyenne vers le haut. Les statistiques sur les langages montrent leur prévalence relative dans l'échantillon. La comparaison organisations/individus quantifie l'écart de popularité moyen entre les deux groupes. Enfin, les métriques de diversité technologique et leur corrélation avec la popularité fournissent une mesure objective de l'importance de la polyvalence vs spécialisation.\n\n## Interprétation\n\n### 1. Distribution de la popularité\n\nLa distribution des étoiles est fortement asymétrique, avec quelques profils exceptionnellement populaires (outliers) et une grande majorité de profils avec une popularité modérée. Cette distribution justifie l'utilisation d'échelles logarithmiques pour les visualisations.\n\n### 2. Impact des langages de programmation\n\nL'analyse révèle que :\n\n- **Python** et **JavaScript** sont parmi les langages les plus représentés dans les profils populaires.\n- Les tests statistiques (Wilcoxon) permettent de déterminer si l'utilisation d'un langage spécifique est associée à une popularité significativement plus élevée.\n\n### 3. Organisations vs Individus\n\nLes organisations majeures (OpenAI, GitHub, Microsoft, Google) présentent généralement des niveaux de popularité très élevés, mais cette différence doit être interprétée avec prudence compte tenu du faible nombre d'organisations dans l'échantillon.\n\n### 4. Diversité technologique\n\nL'analyse de corrélation entre le nombre de langages utilisés et la popularité permet d'évaluer si la polyvalence technologique est un facteur de succès.\n\n## Limitations\n\n1. **Taille de l'échantillon** : 30 profils est un échantillon relativement petit pour des généralisations statistiques.\n2. **Biais de sélection** : Les profils sélectionnés sont déjà parmi les plus populaires, ce qui peut créer un biais.\n3. **Facteurs confondants** : De nombreux autres facteurs (qualité du code, documentation, communauté, etc.) influencent la popularité et ne sont pas pris en compte dans cette analyse.\n\n## Perspectives\n\nCette analyse pourrait être étendue en :\n\n- Augmentant la taille de l'échantillon\n- Ajoutant des variables temporelles (évolution dans le temps)\n- Analysant d'autres métriques (forks, contributions, etc.)\n- Intégrant des données sur la localisation géographique des contributeurs\n\n---\n\n# Références\n\n- Wickham, H., & Grolemund, G. (2016). *R for Data Science*. O'Reilly Media.\n- Wickham, H., Averick, M., Bryan, J., Chang, W., McGowan, L., François, R., ... & Yutani, H. (2019). Welcome to the tidyverse. *Journal of Open Source Software*, 4(43), 1686.\n- R Core Team (2023). *R: A language and environment for statistical computing*. R Foundation for Statistical Computing, Vienna, Austria.\n\n","srcMarkdownNoYaml":"\n\n# Introduction\n\nCe document présente une analyse statistique complète des profils GitHub les plus influents à travers le monde. GitHub est la plateforme de référence pour le développement collaboratif, et le nombre d'étoiles (stars) récoltées par un utilisateur est devenu un indicateur clé de sa popularité et de son impact dans la communauté Open Source.\n\n## Objectifs de l'analyse\n\nNous tenterons de répondre aux questions suivantes :\n\n1. **Distribution de la popularité** : Comment la popularité est-elle distribuée entre ces différents profils ?\n2. **Impact des langages** : Le choix des langages de programmation (comme Python ou JavaScript) influence-t-il le succès d'un profil ?\n3. **Types de profils** : Existe-t-il des différences notables entre les comptes individuels et les organisations ?\n4. **Diversité technologique** : La diversité des langages utilisés est-elle corrélée à la popularité ?\n\n# Chargement des bibliothèques et des données\n\n## Installation et chargement des packages\n\n```{webr-r}\n# Installation des packages (si nécessaire)\n# install.packages(\"tidyverse\")\n# install.packages(\"wordcloud\")\n# install.packages(\"RColorBrewer\")\n\n# Chargement des bibliothèques\nlibrary(tidyverse)\nlibrary(wordcloud)\nlibrary(RColorBrewer)\n```\n\n## Lecture du fichier de données\n\n```{webr-r}\n# Lecture du fichier CSV (remonter d'un niveau depuis qmd/)\ndf <- read.csv(\"https://raw.githubusercontent.com/siwarchiha07/R_Project/main/profiles_index.csv\", stringsAsFactors = FALSE)\n\n# Aperçu des données\ncat(\"Dimensions du dataset :\", dim(df), \"\\n\")\n```\n\n```{webr-r}\n# Affichage des premières lignes\nhead(df)\n```\n\n```{webr-r}\n# Structure des données (vérification des types de colonnes)\nstr(df)\n```\n\n**Interprétation :** Le dataset contient 30 profils GitHub avec 7 variables principales. La structure des données révèle que chaque profil possède un identifiant unique (login), des informations personnelles (nom, entreprise, localisation), ainsi que des métriques quantitatives (total_stars, nb_repos_fetched) et qualitatives (languages_list). La lecture depuis une URL garantit que les données sont toujours à jour et accessibles.\n\n# Nettoyage et transformation des données\n\n## Remplacement des valeurs manquantes\n\n```{webr-r}\n# Remplacement des valeurs vides par \"Unknown\" dans Location et Company\ndf$location[df$location == \"\" | is.na(df$location)] <- \"Unknown\"\ndf$company[df$company == \"\" | is.na(df$company)] <- \"Unknown\"\n```\n\n**Interprétation :** Le remplacement des valeurs manquantes par \"Unknown\" permet de conserver tous les profils dans l'analyse sans perte d'information. Cette approche est appropriée car certaines informations peuvent simplement ne pas être renseignées par les utilisateurs GitHub plutôt que d'être réellement manquantes. Cela évite les biais liés à l'élimination des données incomplètes.\n\n## Création de variables \"flags\" pour les langages\n\n```{webr-r}\n# Création de variables booléennes pour les langages les plus populaires\ndf <- df %>%\n  mutate(\n    has_python = grepl(\"Python\", languages_list),\n    has_javascript = grepl(\"JavaScript\", languages_list),\n    has_typescript = grepl(\"TypeScript\", languages_list)\n  )\n\n# Vérification du résultat\nhead(df[, c(\"login\", \"total_stars\", \"has_python\", \"has_javascript\", \"has_typescript\")])\n```\n\n**Interprétation :** La création de variables booléennes facilite l'analyse comparative entre profils utilisant ou non un langage donné. Ces variables permettent de tester si l'utilisation d'un langage spécifique est associée à une popularité différente. Python, JavaScript et TypeScript sont choisis car ce sont parmi les langages les plus populaires et demandés dans l'écosystème de développement moderne.\n\n# Analyse descriptive et graphiques\n\n## Statistiques descriptives\n\n```{webr-r}\n# Statistiques descriptives pour les variables quantitatives\nsummary(df[, c(\"total_stars\", \"nb_repos_fetched\")])\n```\n\n```{webr-r}\n# Fréquences pour certaines variables qualitatives\ncat(\"\\n=== Distribution par langage Python ===\\n\")\ntable(df$has_python)\n\ncat(\"\\n=== Distribution par langage JavaScript ===\\n\")\ntable(df$has_javascript)\n\ncat(\"\\n=== Distribution par langage TypeScript ===\\n\")\ntable(df$has_typescript)\n```\n\n**Interprétation :** Les statistiques descriptives révèlent une importante variabilité dans le nombre d'étoiles, avec des valeurs extrêmes qui suggèrent une distribution asymétrique. La médiane et la moyenne du nombre d'étoiles sont probablement très différentes, indiquant la présence de quelques profils exceptionnellement populaires. Les tableaux de fréquences montrent la prévalence de chaque langage dans l'échantillon, permettant d'identifier les langages les plus représentés.\n\n## Distribution du nombre total d'étoiles\n\n```{webr-r}\n# Histogramme de la distribution des étoiles\nggplot(df, aes(x = total_stars)) +\n  geom_histogram(fill = \"steelblue\", bins = 15, color = \"white\") +\n  labs(\n    title = \"Distribution du nombre total d'étoiles\",\n    subtitle = \"Répartition de la popularité parmi les profils GitHub\",\n    x = \"Nombre d'étoiles\",\n    y = \"Fréquence\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 14, face = \"bold\"),\n    plot.subtitle = element_text(size = 12)\n  )\n```\n\n**Interprétation :** L'histogramme révèle une distribution fortement asymétrique (skewed right) avec une queue longue vers les valeurs élevées. Cela signifie que la majorité des profils ont un nombre modéré d'étoiles, tandis qu'un petit nombre de profils concentrent une part disproportionnée de la popularité totale. Cette distribution suit probablement une loi de Pareto (loi des 80/20), caractéristique des systèmes sociaux où quelques acteurs dominent.\n\n## Impact des langages sur la popularité\n\n### Python\n\n```{webr-r}\n# Boxplot : Python vs les autres\nggplot(df, aes(x = has_python, y = total_stars, fill = has_python)) +\n  geom_boxplot(alpha = 0.7) +\n  scale_y_log10() +  # Utilisation d'une échelle log car les écarts sont énormes\n  labs(\n    title = \"Popularité : Profils Python vs Autres\",\n    subtitle = \"Comparaison du nombre d'étoiles (échelle logarithmique)\",\n    x = \"Utilise Python\",\n    y = \"Total Stars (Log Scale)\"\n  ) +\n  scale_fill_manual(values = c(\"FALSE\" = \"#E8E8E8\", \"TRUE\" = \"#377EB8\")) +\n  theme_light() +\n  theme(legend.position = \"none\")\n```\n\n**Interprétation :** Le boxplot en échelle logarithmique permet de comparer visuellement la distribution des étoiles entre les deux groupes. Si les boîtes à moustaches sont à des hauteurs différentes, cela suggère un écart potentiel de popularité. L'échelle logarithmique est essentielle ici car elle compresse les très grandes différences et rend la visualisation lisible. Une médiane plus élevée pour le groupe \"Python = TRUE\" suggérerait que Python pourrait être associé à une plus grande popularité.\n\n### JavaScript\n\n```{webr-r}\n# Impact de JavaScript sur la popularité\nggplot(df, aes(x = has_javascript, y = total_stars, fill = has_javascript)) +\n  geom_boxplot(alpha = 0.7) +\n  scale_y_log10() +\n  labs(\n    title = \"Impact de JavaScript sur la popularité\",\n    subtitle = \"Comparaison du nombre d'étoiles (échelle logarithmique)\",\n    x = \"Utilise JavaScript\",\n    y = \"Total Stars (Log)\"\n  ) +\n  scale_fill_manual(values = c(\"FALSE\" = \"#E8E8E8\", \"TRUE\" = \"#FDB462\")) +\n  theme_classic() +\n  theme(legend.position = \"none\")\n```\n\n**Interprétation :** Similaire à l'analyse Python, ce graphique compare la popularité des profils utilisant JavaScript. JavaScript étant le langage le plus utilisé pour le développement web, on pourrait s'attendre à ce que les profils utilisant JavaScript soient plus nombreux. Cependant, cela ne garantit pas nécessairement une plus grande popularité moyenne, car la qualité et la visibilité des projets sont plus importantes que le simple choix technologique.\n\n# Tests statistiques\n\n## Test de Wilcoxon pour Python\n\n**Question de recherche** : Est-ce que les profils utilisant Python ont significativement plus d'étoiles que les autres ?\n\n```{webr-r}\n# Test statistique de Wilcoxon pour Python\ncat(\"=== Test de différence significative pour Python ===\\n\")\ntest_python <- wilcox.test(total_stars ~ has_python, data = df)\nprint(test_python)\n\n# Interprétation\nif (test_python$p.value < 0.05) {\n  cat(\"\\n✓ Résultat significatif (p < 0.05) : Il existe une différence significative\\n\")\n} else {\n  cat(\"\\n✗ Résultat non significatif (p >= 0.05) : Pas de différence significative détectée\\n\")\n}\n```\n\n**Interprétation :** Le test de Wilcoxon (test non-paramétrique de Mann-Whitney) est choisi car il ne fait pas d'hypothèse sur la distribution normale des données, ce qui est approprié ici compte tenu de l'asymétrie observée. Si p < 0.05, on rejette l'hypothèse nulle d'égalité des distributions et on conclut qu'il existe une différence statistiquement significative entre les deux groupes. Cependant, un résultat significatif ne signifie pas nécessairement une causalité - il pourrait s'agir d'une simple corrélation due à d'autres facteurs.\n\n## Test de Wilcoxon pour JavaScript\n\n```{webr-r}\n# Test statistique de Wilcoxon pour JavaScript\ncat(\"=== Test de différence significative pour JavaScript ===\\n\")\ntest_javascript <- wilcox.test(total_stars ~ has_javascript, data = df)\nprint(test_javascript)\n\n# Interprétation\nif (test_javascript$p.value < 0.05) {\n  cat(\"\\n✓ Résultat significatif (p < 0.05) : Il existe une différence significative\\n\")\n} else {\n  cat(\"\\n✗ Résultat non significatif (p >= 0.05) : Pas de différence significative détectée\\n\")\n}\n```\n\n**Interprétation :** De la même manière que pour Python, ce test évalue si l'utilisation de JavaScript est associée à une différence significative de popularité. Un résultat non significatif pourrait indiquer que JavaScript est si répandu qu'il n'apporte pas de distinction particulière, ou que d'autres facteurs (qualité du code, timing, marketing) sont plus déterminants pour le succès que le simple choix du langage.\n\n# Organisations vs Individus\n\n```{webr-r}\n# Identification des organisations dans le dataset\norgs_list <- c(\"openai\", \"github\", \"microsoft\", \"google\")\n\ndf <- df %>%\n  mutate(\n    type_profil = ifelse(login %in% orgs_list, \"Organisation\", \"Individu\")\n  )\n\n# Vérification\ntable(df$type_profil)\n```\n\n```{webr-r}\n# Visualisation : Organisations vs Individus\nggplot(df, aes(x = type_profil, y = total_stars, fill = type_profil)) +\n  geom_boxplot(alpha = 0.7) +\n  scale_y_log10() +  # Échelle log pour mieux voir la différence\n  labs(\n    title = \"Popularité : Organisations vs Individus\",\n    subtitle = \"Comparaison du nombre d'étoiles (échelle logarithmique)\",\n    x = \"Type de Profil\",\n    y = \"Total Stars (Log Scale)\"\n  ) +\n  scale_fill_manual(values = c(\"Individu\" = \"#66C2A5\", \"Organisation\" = \"#FC8D62\")) +\n  theme_light() +\n  theme(legend.position = \"none\")\n```\n\n**Interprétation :** Cette comparaison permet d'évaluer si les organisations ont un avantage structurel (ressources, équipes, visibilité) par rapport aux développeurs individuels. Les organisations majeures bénéficient généralement de budgets marketing, de communautés établies et de ressources pour maintenir et promouvoir leurs projets. Cependant, l'échantillon est petit pour les organisations (4 sur 30), ce qui limite la généralisation des résultats. Si les organisations montrent une popularité plus élevée, cela pourrait refléter leur capacité à investir dans le marketing et la maintenance à long terme.\n\n# Relation entre quantité de dépôts et popularité\n\n```{webr-r}\n# Relation entre nombre de dépôts et popularité\nggplot(df, aes(x = nb_repos_fetched, y = total_stars)) +\n  geom_point(color = \"darkgreen\", size = 3, alpha = 0.7) +\n  geom_smooth(method = \"lm\", color = \"red\", linetype = \"dashed\", se = TRUE) +\n  labs(\n    title = \"Relation : Nombre de dépôts récupérés vs Stars\",\n    subtitle = \"Si la ligne est plate, la quantité n'influence pas la popularité\",\n    x = \"Nombre de dépôts (nb_repos_fetched)\",\n    y = \"Total Stars\"\n  ) +\n  theme_minimal()\n```\n\n**Interprétation :** Ce graphique explore si \"plus de projets = plus de popularité\". La ligne de régression montre la tendance générale : une pente positive suggère que publier plus de projets pourrait augmenter la visibilité, tandis qu'une ligne plate indiquerait que la quantité n'est pas le facteur déterminant. Cependant, la relation pourrait être inverse : certains profils très populaires peuvent avoir moins de projets mais de meilleure qualité. La bande de confiance (zone grise) montre l'incertitude autour de cette relation.\n\n## Test de corrélation\n\n```{webr-r}\n# Test de corrélation entre nombre de dépôts et étoiles\ncor_test_repos <- cor.test(df$nb_repos_fetched, df$total_stars, method = \"spearman\")\ncat(\"=== Test de corrélation (Spearman) ===\\n\")\nprint(cor_test_repos)\n```\n\n**Interprétation :** Le test de corrélation de Spearman mesure la force de la relation monotone (pas nécessairement linéaire) entre les deux variables. Un coefficient proche de 0 indique l'absence de corrélation, tandis qu'une valeur proche de +1 ou -1 indique une forte corrélation positive ou négative. Le test de Spearman est préféré au test de Pearson car il est plus robuste aux valeurs aberrantes et ne nécessite pas d'hypothèse de normalité.\n\n# Analyse de la diversité technologique\n\n## Calcul du nombre de langages par profil\n\n```{webr-r}\n# Calculer le nombre de langages par profil\ndf$num_languages <- stringr::str_count(df$languages_list, \",\") + 1\n\n# Statistiques descriptives\ncat(\"=== Statistiques sur le nombre de langages ===\\n\")\nsummary(df$num_languages)\n\n# Visualisation\nggplot(df, aes(x = num_languages)) +\n  geom_histogram(fill = \"purple\", bins = 10, color = \"white\", alpha = 0.7) +\n  labs(\n    title = \"Distribution du nombre de langages utilisés\",\n    x = \"Nombre de langages\",\n    y = \"Fréquence\"\n  ) +\n  theme_minimal()\n```\n\n**Interprétation :** Le calcul du nombre de langages permet d'évaluer la diversité technologique de chaque profil. Un nombre élevé de langages pourrait indiquer une polyvalence technique, mais aussi une dispersion potentielle des efforts. L'histogramme montre la distribution de cette diversité dans l'échantillon, révélant si la plupart des profils se spécialisent (peu de langages) ou sont polyvalents (beaucoup de langages).\n\n## Corrélation entre diversité et popularité\n\n```{webr-r}\n# Test de corrélation de Spearman (adapté aux petites données non-normales)\ncor_test_lang <- cor.test(df$num_languages, df$total_stars, method = \"spearman\")\n\ncat(\"=== Test de corrélation : Nombre de langages vs Popularité ===\\n\")\nprint(cor_test_lang)\n```\n\n**Interprétation :** Ce test évalue si la diversité technologique est un atout ou un handicap pour la popularité. Une corrélation positive suggérerait que la polyvalence est appréciée, tandis qu'une corrélation négative pourrait indiquer que la spécialisation mène à de meilleurs résultats. Une absence de corrélation significative signifierait que la diversité technologique n'est pas un facteur déterminant de la popularité.\n\n```{webr-r}\n# Visualisation de la relation\nggplot(df, aes(x = num_languages, y = total_stars)) +\n  geom_point(aes(color = total_stars), size = 3, alpha = 0.7) +\n  geom_smooth(method = \"lm\", se = TRUE, color = \"red\", linetype = \"dashed\") +\n  scale_y_log10() +\n  scale_color_gradient(low = \"blue\", high = \"red\") +\n  labs(\n    title = \"Diversité technologique vs Popularité\",\n    subtitle = \"Relation entre le nombre de langages et le nombre d'étoiles\",\n    x = \"Nombre de langages utilisés\",\n    y = \"Total Stars (Log)\",\n    color = \"Étoiles\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"right\")\n```\n\n**Interprétation :** Le nuage de points avec gradient de couleur permet de visualiser à la fois la relation entre diversité et popularité, ainsi que l'identification visuelle des profils les plus populaires (points rouges). La ligne de régression indique la tendance générale, mais les points individuels peuvent révéler des exceptions intéressantes. Par exemple, certains profils peuvent être très populaires avec peu de langages (spécialisation réussie) ou avec beaucoup de langages (polyvalence réussie).\n\n# Analyse de la \"puissance\" des langages\n\n## Identification des superstars\n\n```{webr-r}\n# Définir le seuil du top 25%\nseuil_top <- quantile(df$total_stars, 0.75)\ndf$is_superstar <- df$total_stars >= seuil_top\n\ncat(\"=== Seuil pour être considéré comme 'Superstar' (top 25%) ===\\n\")\ncat(\"Seuil :\", seuil_top, \"étoiles\\n\\n\")\ncat(\"Nombre de superstars :\", sum(df$is_superstar), \"\\n\")\n```\n\n**Interprétation :** La définition des \"superstars\" comme étant dans le top 25% permet de créer un groupe d'élite pour comparaison. Le quantile 0.75 (Q3) est un seuil objectif qui sépare naturellement les profils les plus performants. Environ 7-8 profils devraient être identifiés comme superstars, ce qui représente un échantillon suffisant pour des comparaisons statistiques significatives.\n\n## Comparaison des langages pour les superstars\n\n```{webr-r}\n# Comparaison des langages pour les superstars vs autres\nlang_summary <- df %>%\n  group_by(is_superstar) %>%\n  summarise(\n    Pct_Python = mean(has_python) * 100,\n    Pct_JS = mean(has_javascript) * 100,\n    Pct_TS = mean(has_typescript) * 100,\n    .groups = \"drop\"\n  )\n\ncat(\"=== Pourcentage d'utilisation des langages ===\\n\")\ncat(\"Chez les Superstars vs Autres :\\n\")\nprint(lang_summary)\n```\n\n**Interprétation :** Cette analyse compare les préférences technologiques entre les profils les plus populaires et les autres. Si un langage apparaît significativement plus souvent chez les superstars, cela pourrait suggérer que ce langage offre des avantages (écosystème riche, communauté active, outils performants) ou que les superstars tendent à choisir ce langage pour des raisons stratégiques. Cependant, il faut éviter de conclure à une relation causale directe.\n\n## Visualisation comparée\n\n```{webr-r}\n# Préparation des données pour la visualisation\nlang_summary_long <- lang_summary %>%\n  pivot_longer(\n    cols = c(Pct_Python, Pct_JS, Pct_TS),\n    names_to = \"Langage\",\n    values_to = \"Pourcentage\"\n  ) %>%\n  mutate(\n    Langage = case_when(\n      Langage == \"Pct_Python\" ~ \"Python\",\n      Langage == \"Pct_JS\" ~ \"JavaScript\",\n      Langage == \"Pct_TS\" ~ \"TypeScript\"\n    ),\n    Type = ifelse(is_superstar, \"Superstar\", \"Autres\")\n  )\n\n# Graphique en barres groupées\nggplot(lang_summary_long, aes(x = Langage, y = Pourcentage, fill = Type)) +\n  geom_bar(stat = \"identity\", position = \"dodge\", alpha = 0.8) +\n  labs(\n    title = \"Utilisation des langages : Superstars vs Autres\",\n    subtitle = \"Pourcentage de profils utilisant chaque langage\",\n    x = \"Langage de programmation\",\n    y = \"Pourcentage (%)\",\n    fill = \"Type de profil\"\n  ) +\n  scale_fill_manual(values = c(\"Superstar\" = \"#E31A1C\", \"Autres\" = \"#1F78B4\")) +\n  theme_minimal() +\n  theme(legend.position = \"right\")\n```\n\n**Interprétation :** Le graphique en barres groupées permet une comparaison visuelle directe. Des barres de hauteur similaire indiquent que le langage est également utilisé dans les deux groupes, tandis que des différences importantes suggèrent une préférence marquée dans un groupe. Cette visualisation aide à identifier rapidement si certains langages sont des \"marchés\" des superstars ou si la répartition est homogène.\n\n# Détection des valeurs atypiques (Outliers)\n\n```{webr-r}\n# Identification des outliers avec la méthode IQR\nQ1 <- quantile(df$total_stars, 0.25)\nQ3 <- quantile(df$total_stars, 0.75)\nIQR_val <- Q3 - Q1\nborne_sup <- Q3 + 1.5 * IQR_val\n\noutliers <- df[df$total_stars > borne_sup, ]\n\ncat(\"=== Détection des valeurs atypiques (méthode IQR) ===\\n\")\ncat(\"Q1 :\", Q1, \"\\n\")\ncat(\"Q3 :\", Q3, \"\\n\")\ncat(\"IQR :\", IQR_val, \"\\n\")\ncat(\"Borne supérieure (Q3 + 1.5 × IQR) :\", borne_sup, \"\\n\\n\")\ncat(\"Nombre de profils considérés comme des anomalies statistiques (Superstars) :\", \n    nrow(outliers), \"\\n\\n\")\ncat(\"=== Profils identifiés comme outliers ===\\n\")\nprint(outliers[, c(\"login\", \"name\", \"total_stars\", \"company\")])\n```\n\n**Interprétation :** La méthode IQR (Interquartile Range) est une technique standard pour identifier les valeurs atypiques. Tout profil dont le nombre d'étoiles dépasse Q3 + 1.5×IQR est considéré comme un outlier. Ces profils sont statistiquement exceptionnels - ils se démarquent nettement du reste de la population. Identifier ces profils permet de comprendre les facteurs qui créent des succès exceptionnels, mais aussi de décider s'il faut les inclure ou les exclure de certaines analyses qui pourraient être biaisées par leur présence.\n\n```{webr-r}\n# Visualisation avec identification des outliers\nggplot(df, aes(x = \"\", y = total_stars)) +\n  geom_boxplot(fill = \"lightblue\", alpha = 0.7, outlier.color = \"red\", outlier.size = 3) +\n  scale_y_log10() +\n  labs(\n    title = \"Distribution des étoiles avec détection des outliers\",\n    subtitle = \"Les points rouges représentent les valeurs atypiques\",\n    x = \"\",\n    y = \"Total Stars (Log Scale)\"\n  ) +\n  theme_minimal()\n```\n\n**Interprétation :** Le boxplot visualise clairement les outliers comme des points rouges au-delà des moustaches. Cette représentation permet de voir immédiatement l'ampleur de l'écart entre les profils normaux et les exceptions. L'échelle logarithmique est cruciale ici car elle permet de voir à la fois les profils normaux et les outliers sur le même graphique, sans que les outliers masquent complètement la distribution principale.\n\n# Analyse de texte : Nuage de mots des entreprises\n\n```{webr-r}\n# Créer un tableau de fréquence des entreprises (en ignorant \"Unknown\" et valeurs vides)\ncomp_freq <- df %>%\n  filter(company != \"Unknown\" & company != \"\" & !is.na(company)) %>%\n  count(company, sort = TRUE)\n\n# Vérifier s'il y a des données\nif (nrow(comp_freq) > 0) {\n  # Créer le nuage de mots\n  wordcloud(\n    words = comp_freq$company,\n    freq = comp_freq$n,\n    min.freq = 1,\n    colors = brewer.pal(8, \"Dark2\"),\n    random.order = FALSE,\n    rot.per = 0.35,\n    scale = c(3, 0.5)\n  )\n  \n  cat(\"=== Fréquence des entreprises ===\\n\")\n  print(comp_freq)\n} else {\n  cat(\"Pas assez de données d'entreprises pour créer un nuage de mots.\\n\")\n}\n```\n\n**Interprétation :** Le nuage de mots (wordcloud) offre une visualisation intuitive de l'écosystème des entreprises représentées dans l'échantillon. La taille des mots est proportionnelle à leur fréquence, permettant d'identifier rapidement les entreprises les plus présentes. Cela révèle quelles organisations emploient ou attirent les développeurs les plus influents sur GitHub. Le tableau de fréquences fournit les valeurs exactes pour une analyse plus précise. Cette analyse contextuelle aide à comprendre l'environnement professionnel des profils étudiés.\n\n# Synthèse et conclusions\n\n## Résultats principaux\n\n```{webr-r}\ncat(\"=== SYNTHÈSE DES RÉSULTATS ===\\n\\n\")\n\n# 1. Distribution de la popularité\ncat(\"1. DISTRIBUTION DE LA POPULARITÉ\\n\")\ncat(\"   - Médiane des étoiles :\", median(df$total_stars), \"\\n\")\ncat(\"   - Moyenne des étoiles :\", round(mean(df$total_stars), 2), \"\\n\")\ncat(\"   - Écart-type :\", round(sd(df$total_stars), 2), \"\\n\\n\")\n\n# 2. Impact des langages\ncat(\"2. IMPACT DES LANGAGES\\n\")\ncat(\"   - Profils utilisant Python :\", sum(df$has_python), \"sur\", nrow(df), \"\\n\")\ncat(\"   - Profils utilisant JavaScript :\", sum(df$has_javascript), \"sur\", nrow(df), \"\\n\")\ncat(\"   - Profils utilisant TypeScript :\", sum(df$has_typescript), \"sur\", nrow(df), \"\\n\\n\")\n\n# 3. Types de profils\ncat(\"3. TYPES DE PROFILS\\n\")\nprofile_summary <- df %>%\n  group_by(type_profil) %>%\n  summarise(\n    Nombre = n(),\n    Moyenne_étoiles = round(mean(total_stars), 2),\n    Médiane_étoiles = round(median(total_stars), 2),\n    .groups = \"drop\"\n  )\nprint(profile_summary)\ncat(\"\\n\")\n\n# 4. Diversité technologique\ncat(\"4. DIVERSITÉ TECHNOLOGIQUE\\n\")\ncat(\"   - Nombre moyen de langages :\", round(mean(df$num_languages), 2), \"\\n\")\ncat(\"   - Nombre médian de langages :\", median(df$num_languages), \"\\n\")\ncat(\"   - Corrélation avec la popularité (Spearman) :\", \n    round(cor_test_lang$estimate, 3), \"\\n\")\ncat(\"   - p-value :\", round(cor_test_lang$p.value, 4), \"\\n\")\n```\n\n**Interprétation :** Cette synthèse quantitative résume les principales découvertes de l'analyse. La comparaison entre médiane et moyenne révèle le degré d'asymétrie : si la moyenne est beaucoup plus élevée que la médiane, cela confirme la présence de quelques profils extrêmement populaires qui tirent la moyenne vers le haut. Les statistiques sur les langages montrent leur prévalence relative dans l'échantillon. La comparaison organisations/individus quantifie l'écart de popularité moyen entre les deux groupes. Enfin, les métriques de diversité technologique et leur corrélation avec la popularité fournissent une mesure objective de l'importance de la polyvalence vs spécialisation.\n\n## Interprétation\n\n### 1. Distribution de la popularité\n\nLa distribution des étoiles est fortement asymétrique, avec quelques profils exceptionnellement populaires (outliers) et une grande majorité de profils avec une popularité modérée. Cette distribution justifie l'utilisation d'échelles logarithmiques pour les visualisations.\n\n### 2. Impact des langages de programmation\n\nL'analyse révèle que :\n\n- **Python** et **JavaScript** sont parmi les langages les plus représentés dans les profils populaires.\n- Les tests statistiques (Wilcoxon) permettent de déterminer si l'utilisation d'un langage spécifique est associée à une popularité significativement plus élevée.\n\n### 3. Organisations vs Individus\n\nLes organisations majeures (OpenAI, GitHub, Microsoft, Google) présentent généralement des niveaux de popularité très élevés, mais cette différence doit être interprétée avec prudence compte tenu du faible nombre d'organisations dans l'échantillon.\n\n### 4. Diversité technologique\n\nL'analyse de corrélation entre le nombre de langages utilisés et la popularité permet d'évaluer si la polyvalence technologique est un facteur de succès.\n\n## Limitations\n\n1. **Taille de l'échantillon** : 30 profils est un échantillon relativement petit pour des généralisations statistiques.\n2. **Biais de sélection** : Les profils sélectionnés sont déjà parmi les plus populaires, ce qui peut créer un biais.\n3. **Facteurs confondants** : De nombreux autres facteurs (qualité du code, documentation, communauté, etc.) influencent la popularité et ne sont pas pris en compte dans cette analyse.\n\n## Perspectives\n\nCette analyse pourrait être étendue en :\n\n- Augmentant la taille de l'échantillon\n- Ajoutant des variables temporelles (évolution dans le temps)\n- Analysant d'autres métriques (forks, contributions, etc.)\n- Intégrant des données sur la localisation géographique des contributeurs\n\n---\n\n# Références\n\n- Wickham, H., & Grolemund, G. (2016). *R for Data Science*. O'Reilly Media.\n- Wickham, H., Averick, M., Bryan, J., Chang, W., McGowan, L., François, R., ... & Yutani, H. (2019). Welcome to the tidyverse. *Journal of Open Source Software*, 4(43), 1686.\n- R Core Team (2023). *R: A language and environment for statistical computing*. R Foundation for Statistical Computing, Vienna, Austria.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["thpe.css"],"toc":true,"number-sections":true,"filters":["webr"],"output-file":"01-analyse-profiles-github.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.26","bibliography":["../bib.bib"],"csl":"../apa.csl","theme":"cosmo","title":"Analyse Statistique des Profils GitHub Influents","date":"today","webr":{"packages":["tidyverse","ggplot2","wordcloud","RColorBrewer","stringr"]},"code-summary":"Afficher le code"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html","pdf"]}